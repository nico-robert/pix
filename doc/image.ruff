# File generated by pixdoc.tcl
namespace eval ::pix {
            namespace eval img {
                # Ruff documentation
                variable _ruff_preamble {}
            }
        }
proc pix::img::new {size} {
  # Sets a new image.
  #
  # size  - list width,height
  #
  # Returns: A *new* [img] object.
}
proc pix::img::copy {image} {
  # This procedure creates a new image by copying the contents 
  # of the given image object.
  #
  # image - [img::new]
  #
  # Returns: A *new* [img] object.
}
proc pix::img::draw {image image2 {matrix3 {mat3}} {blendMode {NormalBlend}}} {
  # Draws one image onto another using a matrix transform and color blending.
  #
  # image     - [img::new]
  # image2    - [img::new]
  # matrix3   - list 
  # blendMode - Enum value 
  #
  # Returns: Nothing.
}
proc pix::img::fill {image value} {
  # Fills the image with the color.
  #
  # image   - [img::new]
  # value   - string [color] or [paint] object
  #
  # This proc takes an image object and a color or paint object as arguments.
  # It will fill the image with the specified color or paint object.
  # The color or paint object can be specified as a string or as an object.
  # If a string is specified, it should be a valid color string.
  # If a paint object is specified, it should be a valid paint object.
  # The paint object can be created using the *pix::paint::new* proc.
  #
  # Returns: Nothing.
}
proc pix::img::readImage {filePath} {
  # Read image file.
  #
  # filePath - path file
  #
  # This proc will attempt to read the image file and create a new image
  # object from it.
  #
  # Returns: A *new* [img] object.
}
proc pix::img::fillPath {image pathValue paintValue {matrix {mat3idendity}}} {
  # Fills a path with a color or paint object.
  #
  # image      - The [img::new] object to draw on.
  # pathValue  - A string containing a path or a path object.
  #             The path can be specified as a string like this:
  #             **M 0 0 L 100 0 L 100 100 Z**
  #             or as a path object created with the *pix::path::new* proc.
  # paintValue - A string containing a [color] or a [paint] object.
  #             The color can be specified as a string like this:
  #             **#FF0000** or as a paint object created with the
  #             *pix::paint::new* proc.
  # matrix     - A  matrix to transform the path with.
  #             The matrix should be a **3x3** matrix specified as a list of 9
  #             numbers.
  #
  # Returns: Nothing.
}
proc pix::img::strokePath {image value color options} {
  # Strokes a path with a color or a paint object and optional
  # stroke and line join options.
  #
  # image   - The [img::new] object to draw on.
  # value   - A string path or a [path] object created with the
  #          *pix::path::new* Tcl proc.
  # color   - A string [color] or a [paint] object created with the
  #          *pix::paint::new* Tcl proc.
  # options - A Tcl dict, see attributes below.
  #
  #  * A dictionary of options to customize the stroke. The options are:<br>
  #  #Begintable
  #  **strokeWidth** : The width of the stroke.
  #  **transform**   : The transformation matrix to apply to the path.
  #  **lineCap**     : The line cap style (Enum).
  #  **miterLimit**  : The miter limit for the line join.
  #  **lineJoin**    : The line join style (Enum).
  #  **dashes**      : The dashes to apply to the stroke.
  #  #EndTable
  #
  # Returns: Nothing.
}
proc pix::img::blur {image radius {color {transparent}}} {
  # Applies Gaussian blur to the image given a radius.
  #
  # image   - [img::new]
  # radius  - double value
  # color   - string [color] 
  #
  # Returns: Nothing.
}
proc pix::img::shadow {image options} {
  # Create a shadow of the image with the offset, spread and blur.
  #
  # image   - [img::new]
  # options - dict (offset, spread, blur, [color])
  #
  # Returns: Nothing.
}
proc pix::img::fillText {image object args} {
  # Fills the image with the rendered text.
  #
  # image  - [img::new]
  # object - [font::typeset] or [font::readFont] object
  # args   - A Tcl dict (options described below)
  #
  # There are two ways to use this proc:
  #
  # 1. With an [font::typeset] object:<br>
  #    * `$img arrangement {?matrix3 ?value}`<br>
  #    This will render the arrangement onto the image. If the matrix3 optional
  #    argument is provided, it will be used to transform the arrangement before
  #    rendering.
  #
  # 2. With a [font] object and a `text` string:<br>
  #    * `$img font text options`<br>
  #    This will render the text string onto the image using the font object.
  #    The options dict can be used to specify the following:
  #      #Begintable
  #      **transform** : A list transform to apply to the text.
  #      **bounds**    : A list bounds to use for the text.
  #      **hAlign**    : A Enum horizontal alignment of the text.
  #      **vAlign**    : A Enum vertical alignment of the text.
  #     #EndTable
  #
  # In either case, the [img] object is the first argument, and the [font::typeset]
  # or [font::readFont] object is the second argument.
  #
  # Returns: Nothing.
}
proc pix::img::resize {image size} {
  # Resize an image to a given height and width
  #
  # image  - [img::new]
  # size   - list width,height
  #
  # Returns: Nothing.
}
proc pix::img::get {image} {
  # Gets image size.
  #
  # image - [img::new]
  #
  # Returns: A Tcl dictionary with keys containing the width and the 
  # height of the [img].
}
proc pix::img::getPixel {image coordinates} {
  # Gets a pixel at (x, y) or returns transparent black if outside of bounds.
  #
  # image        - [img::new]
  # coordinates  - list x,y (x column of the pixel, y row of the pixel)
  #
  # Returns: A Tcl dictionary with keys (r, g, b, a) representing 
  # the red, green, blue, and alpha (opacity) values of the pixel color.
}
proc pix::img::setPixel {image coordinates color} {
  # Sets a pixel at (x, y) or does nothing if outside of bounds.
  #
  # image       - [img::new]
  # coordinates - list x,y
  # color       - string [color]
  #
  # Returns: Nothing.
}
proc pix::img::applyOpacity {image opacity} {
  # Multiplies alpha of the image by opacity.
  #
  # image    - [img::new]
  # opacity  - double value
  #
  # Image *pix::img::applyOpacity* multiplies the opacity of the image by the
  # opacity parameter. The opacity parameter is a double between
  # 0 and 1. 0 is fully transparent. 1 is fully opaque.<br> Any value
  # inbetween is a mix of the two.
  #
  # Returns: Nothing.
}
proc pix::img::ceil {image} {
  # A value of 0 stays 0. Anything else turns into 255.
  #
  # image - [img::new]
  #
  # The *pix::img::ceil* proc takes an image and replaces all pixels that are
  # not fully transparent (i.e. have an alpha of 0) with a pixel that
  # is fully opaque (i.e. has an alpha of 255). This is useful for
  # creating masks from images.
  #
  # Returns: Nothing.
}
proc pix::img::diff {masterimage image} {
  # Call this proc on the master image, passing the image to
  # compare to the master image. The *pix::img::diff* method returns a dict
  # with two elements.
  #
  # masterimage - [img::new]
  # image       - [img::new]
  #
  # 1. A cdouble representing the difference score between the two
  # images. This score is 0 if the images are identical, and 1 if the
  # images are completely different. The score is a measure of how
  # different the two images are.
  #
  # 2. A new pix image representing the difference between the two
  # images. The difference image is an image that has the same size
  # as the two input images, and the pixels in this image represent
  # the difference between the corresponding pixels in the two
  # images. The difference image will have the same format as the
  # input images.
  #
  # Returns: A Tcl dictionary with keys (score, imgdiff).
}
proc pix::img::flipHorizontal {image} {
  # This method modifies the image in place, flipping it around the Y-axis.
  # As a result, the left and right sides of the image are swapped.
  # This operation is useful for creating mirror images or for certain graphical effects.
  #
  # image - [img::new]
  #
  # Returns: Nothing.
}
proc pix::img::flipVertical {image} {
  # This method modifies the image in place, flipping it around the X-axis.
  #
  # image - [img::new]
  #
  # As a result, the top and bottom sides of the image are swapped.
  # This operation is useful for creating mirror images or for certain graphical effects.
  #
  # Returns: Nothing.
}
proc pix::img::getColor {image coordinates} {
  # Gets a color at (x, y) or returns transparent black if outside of bounds.
  #
  # image        - [img::new]
  # coordinates  - list x,y
  #
  # Returns: A Tcl dictionary with keys (r, g, b, a) representing
  # the red, green, blue, and alpha (opacity) values of the pixel color.
}
proc pix::img::inside {image coordinates} {
  # Returns true if (x, y) is inside the image, false otherwise.
  #
  # image        - [img::new]
  # coordinates  - list x,y
  #
}
proc pix::img::invert {image} {
  # Inverts all of the colors and alpha.
  #
  # image - [img::new]
  #
  # This will flip the image by changing the color and alpha of every pixel.
  # The result will be a new image where every pixel is the exact opposite of
  # the corresponding pixel in the original image.
  #
  # For example, if the original image is entirely white, the resulting image
  # will be entirely black. If the original image is entirely black, the
  # resulting image will be entirely white.
  # This is useful for things like getting the negative of an image, or
  # creating a **reverse** version of an image.
  #
  # Returns: Nothing.
}
proc pix::img::isOneColor {image} {
  # Checks if the entire image is the same color.
  #
  # image - [img::new]
  #
  # Returns: A Tcl boolean value.
}
proc pix::img::isOpaque {image} {
  # Checks if the entire image is opaque (alpha values are all 255).
  #
  # image - [img::new]
  #
  # Returns: A Tcl boolean value.
}
proc pix::img::isTransparent {image} {
  # Checks if this image is fully transparent or not.
  #
  # image - [img::new]
  #
  # Returns true, false otherwise.
}
proc pix::img::magnifyBy2 {image {power {1}}} {
  # Scales image up by 2 ^ power.
  #
  # image  - [img::new]
  # power  - integer value 
  #
  # If only one argument is given (i.e. the image object), just magnify by 2.
  # This is a convenience for the user.
  #
  # Returns: A *new* [img] object.
}
proc pix::img::minifyBy2 {image {power {1}}} {
  # Scales the image down by an integer scale.
  #
  # image  - [img::new]
  # power  - integer value 
  #
  # We were given an integer power as an argument, so we call
  # img.minifyBy2() with that power. This will scale the image
  # down by 2^power.
  #
  # Returns: A *new* [img] object.
}
proc pix::img::opaqueBounds {image} {
  # Checks the bounds of opaque pixels.
  #
  # image - [img::new]
  #
  # Some images have transparency around them,
  # use this to find just the visible part of the image and then use subImage to cut
  # it out. Returns zero rect if whole image is transparent,
  # or just the size of the image if no edge is transparent.
  #
  # Returns A Tcl dictionary with keys *(x, y, w, h)*.
}
proc pix::img::rotate90 {image} {
  # Rotates the image 90 degrees clockwise.
  #
  # image - [img::new]
  #
  # Returns: Nothing.
}
proc pix::img::subImage {image coordinates size} {
  # Gets a sub image from this image.
  #
  # image        - [img::new]
  # coordinates  - list x,y
  # size         - list width,height
  #
  # The subImage function extracts a portion of the original image starting at (x, y) 
  # and spanning the width and height specified.
  #
  # Returns: A *new* [img] object.
}
proc pix::img::superImage {image coordinates size} {
  # Either cuts a sub image or returns a super image with padded transparency.
  #
  # image        - [img::new]
  # coordinates  - list x,y
  # size         - list width,height
  #
  # If the coordinates and size of the superImage are within the bounds of the original image,
  # a sub image is cut from the original image.
  #
  # If the coordinates and size of the superImage are outside the bounds of the original image,
  # a super image is created with the original image centered and padded with transparency.
  # The resulting super image is always the size specified in the arguments.
  #
  # If the resulting super image is different from the original image, a new image is created.
  # If the resulting super image is the same as the original image, the original image is returned.
  #
  # Returns: A *new* [img] object.
}
proc pix::img::fillGradient {image paint} {
  # Fills with the Paint gradient.
  #
  # image  - [img::new]
  # paint  - [paint::new]
  #
  # Returns: Nothing.
}
proc pix::img::strokeText {image object text options} {
  # This procedure is responsible for rendering text onto an image with various styling options.
  #
  # image       - [img].
  # object      - This can either be a 'arrangement' or a [font] object.
  # text        - If the object is a [font] object, this parameter is the text string that needs to be rendered on the image.
  # options     - Check out the description below.
  #
  # * *arroptions*  : (Optional) A Tcl dictionary that contains various attributes for styling the text stroke. 
  #                 These attributes include:<br>
  #                 #Begintable
  #                 **transform**   : A list representing a transformation matrix to apply.
  #                 **strokeWidth** : A double value specifying the width of the stroke.
  #                 **lineCap**     : An enumeration value describing the shape of the stroke's end caps.
  #                 **lineJoin**    : An enumeration value for the shape of the corners in joined lines.
  #                 **miterLimit**  : A double value that limits the length of the miter when lineJoin is set to 'MiterJoin'.
  #                 **dashes**      : A list indicating the pattern for dashed lines.
  #                 #EndTable
  # * *fontoptions* : (Optional) A Tcl dictionary that provides additional styling options specific to the font rendering process:<br>
  #                 #Begintable
  #                 **transform** : A list for a transformation matrix to apply to the text.
  #                 **bounds**    : A list defining the bounding box for the text rendering region.
  #                 **hAlign**    : An enumeration for horizontal alignment of the text.
  #                 **vAlign**    : An enumeration for vertical alignment of the text.
  #                 #EndTable
  #
  # Returns: Nothing.
}
proc pix::img::writeFile {image filePath} {
  # Save image file.
  #
  # image    - [img::new]
  # filePath - string (\*.png|\*.bmp|\*.qoi|\*.ppm)
  #
  # Returns: Nothing.
}
proc pix::img::destroy {value} {
  # Destroy current image or all images if special word `all` is specified.
  #
  # value - [img::new] object or string
  #
  # Returns: Nothing.
}
