# Tcl program to generate pix documentation.
# Note : ruff package is required (https://github.com/apnadkarni/ruff)

# Find tcl procedures in pix.nim
proc parsePIxFile {datapix what} {
    foreach line $datapix {
        if {[string match "*, $what,*" $line]} {
            if {[regexp {\"(.+)\"} $line -> match]} {
                return $match
            }
        }
    }
    return {}
}

# Read example file
proc parseExample {file} {
    set fp [open $file]
    set data [split [read $fp] \n]
    close $fp

    set example {}
    foreach line $data {
        if {[string match "*auto_path*" $line] ||
            [string match "*label*" $line] ||
            [string match "*pack .*" $line]} {
            continue
        }

        lappend example $line

    }
    return $example
}

lappend auto_path [file dirname [file dirname [file dirname [info script]]]]
package require ruff 2.0

set dirpix [file dirname [file dirname [info script]]]

# Write pix.ruff
set fp [open [file join [file dirname [info script]] pix.ruff] w+]
puts $fp {
# File generated by pixdoc.tcl
namespace eval ::pix {
    variable _intro {
        # pix - 2D graphics library
        Tcl/Tk wrapper around [Pixie](https://github.com/treeform/pixie), a full-featured 2D graphics library written in Nim.

        #### Compatibility
        **Tcl/Tk 8.6** (Only tested with Tcl/Tk 8.6.14)

        #### Platforms
        * MacOS 14 x64
        * Windows 10 x64
        * Linux x64

        Source distributions and binary packages can be downloaded [here](https://github.com/nico-robert/pix/releases).

        #### Example
        ```
        package require pix

        # Init 'context' with size + color.
        set ctx [pix::ctx::new {200 200} "white"]

        # Style first rectangle.
        pix::ctx::fillStyle $ctx "rgba(0, 0, 255, 0.5)" ; # blue
        pix::ctx::fillRect $ctx {10 10} {100 100}

        # Style second rectangle.
        pix::ctx::fillStyle $ctx "rgba(255, 0, 0, 0.5)" ; # red
        pix::ctx::fillRect $ctx {50 50} {100 100}

        # Save context in a image file (*.png|*.bmp|*.qoi|*.ppm)
        pix::ctx::writeFile $ctx rectangle.png

        # Or display in label by example
        set p [image create photo]
        pix::drawSurface $ctx $p
        label .l -image $p ; pack .l
        ```
        See [examples](./pix-examples.html) folder for more demos.

        #### Documentation
        A large part of the `pix` documentation comes from the [Pixie API](https://treeform.github.io/pixie/)   
        and source files. 

        #### API
        ** Currently API tested and supported are : **
        *context*  - This namespace provides a 2D API commonly used on the web.
        *font*     - This namespace allows you to write text, load fonts.
        *image*    - Crop, resize, blur image and much more.
        *paint*    - This namespace plays with colors.
        *paths*    - Vector Paths.
        *svg*      - Parse, render SVG (namespace pretty limited)

        #### Acknowledgement:
        * [tclstubs-nimble](https://github.com/mpcjanssen/tclstubs-nimble) (MIT) <br>
        * [Pixie](https://github.com/treeform/pixie) (MIT)

        #### License
    }
}
}
# Read LICENSE file
set fplic [open [file join $dirpix LICENSE]]
set lic [read $fplic]
close $fplic
set lic [string map {\" '} $lic]
puts $fp "append pix::_intro \{\n```\n$lic\n```\n\}"

close $fp

# Read pix.nim to find all tcl procedures 
set fp [open [file join $dirpix src pix.nim]]
set datapix [split [read $fp] \n]
close $fp

# List name files.
foreach name {context paint image svg paths font utils} {

    # Reads source file
    set fp [open [file join $dirpix src $name.nim]]
    set data [split [read $fp] \n]
    close $fp

    set hasProc 0
    set tclproc {}
    set coms {}

    # Writes doc files
    set _file [file join [file dirname [info script]] $name.ruff]
    set fp [open $_file w+]

    set preamble "{}"

    if {$name eq "context"} {
        set ns "ctx"
        set preamble {{
            #### Note
            This namespace provides a 2D API commonly used on the web.\
            For more info, see: [https://developer.mozilla.org/en-US/docs/Web/API/ContextRenderingContext2D]\
            (https://developer.mozilla.org/en-US/docs/Web/API/ContextRenderingContext2D)

            #### Enum BaselineAlignment.
            BaselineAlignment - enum
            TopBaseline - &nbsp;
            HangingBaseline - &nbsp;
            MiddleBaseline - &nbsp;
            AlphabeticBaseline - &nbsp;
            IdeographicBaseline - &nbsp;
            BottomBaseline - &nbsp;

        }}
    } elseif {$name eq "font"} {
        set ns "font"
        set preamble {{
            #### Enum HorizontalAlignment.
            HorizontalAlignment  - enum
            LeftAlign            - &nbsp;
            CenterAlign          - &nbsp;
            RightAlign           - &nbsp;

            #### Enum VerticalAlignment.
            VerticalAlignment    - enum
            TopAlign             - &nbsp;
            MiddleAlign          - &nbsp;
            BottomAlign          - &nbsp;

        }}
    } elseif {$name eq "paint"} {
        set ns "paint"
        set preamble {{
            #### Enum PaintKind.
            PaintKind             - enum
            SolidPaint            - &nbsp;
            ImagePaint            - &nbsp;
            TiledImagePaint       - &nbsp;
            LinearGradientPaint   - &nbsp;
            RadialGradientPaint   - &nbsp;
            AngularGradientPaint  - &nbsp;
        }}

    } elseif {$name eq "image"} {
        set ns "img"
    } elseif {$name eq "paths"} {
        set ns "path"
        set preamble {{
            #### Enum Winding rules.
            WindingRule  - enum
            NonZero      - &nbsp;
            EvenOdd      - &nbsp;
            #### Enum Line cap type for strokes.
            LineCap      - enum
            ButtCap      - &nbsp;
            RoundCap     - &nbsp;
            SquareCap    - &nbsp;
            #### Enum Line join type for strokes.
            LineJoin      - enum
            MiterJoin    - &nbsp;
            RoundJoin    - &nbsp;
            BevelJoin    - &nbsp;
        }}

    } elseif {$name eq "svg"} {
        set ns "svg"
        set preamble {"Load SVG files."}
    } elseif {$name eq "utils"} {
        set preamble {"Help procedures."}
    } else {
        set ns $name
    }
    puts $fp "# File generated by pixdoc.tcl"
    if {$name eq "utils"} {
        puts $fp "namespace eval ::pix {
            variable _ruff_preamble $preamble
        }"
    } else {
        puts $fp "namespace eval ::pix {
            namespace eval $ns {
                # Ruff documentation
                variable _ruff_preamble $preamble
            }
        }"
    }

    foreach line $data {
        if {[string match "*proc *" $line]} {
            if {[regexp {proc (.+)\(} $line -> match]} {
                set tclproc [parsePIxFile $datapix $match]
                if {($tclproc eq "") && ($name ne "utils")} {
                    error "not possible to find name tcl proc '$match'\
                           for this file $name.nim"
                }
                if {($tclproc eq "") && ($name eq "utils")} {
                    set hasProc 0 ; continue
                }
                set hasProc 1
            }
        }
        # Search comments
        if {[string match "*  #*" $line] && $hasProc} {lappend coms $line}

        if {([string match "*try:*" $line] ||
            [string match "*let mess =*" $line]) &&
            $hasProc} {

            set myarg {}
            foreach com $coms {
                if {[string match "* - *" $com]} {
                    set a [lindex [split $com "-"] 0]
                    set a [string map {# "" " " ""} $a]

                    if {[string match "*optional*" $com]} {
                        if {[regexp {optional:([a-zA-Z0-9]+)} $com -> match]} {
                            set a "$a {$match}"
                        } else {
                            set a "$a {}"
                        }
                    }

                    lappend myarg $a
                    if {$a eq "args"} {
                        break
                    }
                }
            }
            puts $fp "proc $tclproc {$myarg} {"
            foreach com $coms {
                if {[string match "*(optional*" $com]} {
                    regsub {\(optional:[a-zA-Z0-9]+\)|\(optional\)} $com {} com 
                }
                puts $fp $com
            }
            puts $fp "}"

            set myarg {}
            set coms {}
            set hasProc 0
            set tclproc {}
        }
    }

    close $fp
}

# Write examples.ruff
set fp [open [file join [file dirname [info script]] examples.ruff] w+]

puts $fp "namespace eval ::examples {
    # Ruff documentation
    variable _ruff_preamble {"

# List examples
foreach {file_name var} {
    blur.tcl image gradient.tcl image heart.tcl image image_tiled.tcl image
    line.tcl ctx masking.tcl image rounded_rectangle.tcl ctx shadow.tcl image
    square.tcl ctx text_spans.tcl image text.tcl image tiger.tcl image
} {
    set ex [parseExample [file join $dirpix examples $file_name]]
    source [file join $dirpix examples $file_name]
    set b64 [pix::toB64 [set $var]]
    puts $fp  "!\[alt img](data:image/png;base64,$b64)"
    puts $fp "```"
    puts $fp "[join $ex \n]"
    puts $fp "```"
    destroy .l1
}
puts $fp "}"
puts $fp "}"


close $fp

foreach name {examples pix context paint image svg paths font utils} {
    source [file join [file dirname [info script]] $name.ruff]
}

# Read pix.nimble to find pix version.
set fp [open [file join $dirpix pix.nimble]]
set datanimble [split [read $fp] \n]
close $fp

# Find out pix version
set version ""
foreach line $datanimble {
    if {[string match "*version*=*" $line]} {
        if {[regexp {[0-9.]+} $line match]} {
            set version $match ; break
        }
    }
}

if {$version eq ""} {
    error "not possible to find out version in pix.nim"
}

# Generate docs
::ruff::document "::examples ::pix [namespace children ::pix]" \
                 -title "pix ${version}: Reference Manual" \
                 -sortnamespaces true \
                 -preamble $::pix::_intro \
                 -compact false \
                 -pagesplit namespace \
                 -navigation sticky \
                 -includesource false \
                 -outdir [file dirname [info script]]  \
                 -outfile "pix.html"

puts "dir     : [file dirname [info script]]"
puts "file    : pix.html"
puts "version : $version"
puts done!
exit 0